#!/usr/bin/env ruby
#================================================================================
# NiosII Bootloader Generator
#================================================================================
require 'optparse'
require 'rexml/document'

def gen_bootldr(args)
  file = args[:sopcinfo]
  puts "Info: Loading #{file}"
  doc = REXML::Document.new(open(file))
  epcs = nil
  REXML::XPath.each(doc, '//module[@kind="altera_avalon_epcs_flash_controller"]') {|mod|
    next if (args[:instance] and args[:instance] != mod.attribute("name"))
    abort "Error: You must specify an instance name by '-i <name>' option." if epcs
    epcs = mod
    break if args[:instance]
  }
  abort "Error: No epcs_flash_controller found." if !epcs
  as = {}
  REXML::XPath.each(epcs, 'assignment/name') {|v|
    as[v.text] = REXML::XPath.first(v.parent, 'value').text
  }
  src = File.dirname(File.expand_path(__FILE__))
  words = as['embeddedsw.CMacro.REGISTER_OFFSET'].to_i / 4
  out = as['embeddedsw.memoryInfo.MEM_INIT_FILENAME']
  do_cmd = proc {|cmd|
    puts "Info: #{cmd}"
    print `#{cmd}`
    abort "Error: Command failed (status=#{$?.exitstatus})" if $?.exitstatus != 0
  }
  cmd = "nios2-elf-gcc -nostartfiles -o #{out}.tmp"
  cmd += " -DEPCS_BOOTROM_WORDS=#{words}"
  if(args[:sectors])
    cmd += " -DEPCS_ELF_SECTORS=#{args[:sectors]}"
  elsif(args[:bytes])
    cmd += " -DEPCS_ELF_BYTES=#{args[:bytes]}"
  elsif(args[:after_sof])
    cmd += " -DEPCS_ELF_AFTER_SOF=#{args[:after_sof]}"
  end
  cmd += " -DEPCS_COMPRESS_LZ4=1"
  cmd += " #{src}/epcs/epcs_bootloader.S"
  do_cmd.call(cmd)
  do_cmd.call("nios2-elf-objcopy --change-section-lma .text=0 #{out}.tmp")
  open("#{out}.hex", "w") {|o|
    o.puts("; This file is created by #{File.basename(__FILE__)}")
    o.puts("; Configuration:")
    o.puts(";   EPCS_BOOTROM_WORDS = 0x%x" % words)
    o.puts(";   EPCS_ELF_SECTORS   = #{args[:sectors]}") if args[:sectors]
    o.puts(";   EPCS_ELF_BYTES     = #{args[:bytes]}") if args[:bytes]
    o.puts(";   EPCS_ELF_AFTER_SOF = #{args[:after_sof]}") if args[:after_sof]
    o.puts(";   EPCS_COMPRESS_LZ4  = 1")
  }
  do_cmd.call("elf2hex --width=32 --input=#{out}.tmp --output=#{out}.tmp --base=0 --end=#{words*4-1}")
  do_cmd.call("cat #{out}.tmp >> #{out}.hex")
  do_cmd.call("rm #{out}.tmp")
  puts "Info: Completed."
  puts "Info: Bootloader is located at '#{out}.hex'"
end

if(__FILE__ == $0)
  args = {}
  OptionParser.new {|o|
    o.banner += " <sopcinfo>"
    o.summary_width = 16
    o.separator("\nAlternative options for ELF placement:")
    o.on('-s SECTORS', 'Number of sectors to place ELF image') {|v| args[:sectors] = v.to_i }
    o.on('-b BYTES', 'Number of bytes to place ELF image') {|v| args[:bytes] = v.to_i }
    o.on('-a', 'Place ELF just after SOF') { args[:after_sof] = 1 }
    o.separator("\nOptional options:")
    o.on('-i INST', 'Instance name of EPCS controller') {|v| args[:instance] = v }
    o.parse!(ARGV)
    if(ARGV.size != 1 or [args[:sectors], args[:bytes], args[:after_sof]].nitems != 1)
      puts o.help
      abort
    end
  }
  args[:sopcinfo] = ARGV.first
  gen_bootldr(args)
end
